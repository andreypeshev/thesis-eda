---
title: "Bachelor's Thesis: Simulation Data EDA"
author: "Andrey Peshev"
output: html_notebook
---
* prb = Percentage Relative Bias  
* mcsd = Monte Carlo Standard Deviation\
* Data generation equation: Y = 1.0 + 0.33X + 0.33Z1 + 0.33Z2 + e\

Simulation parameters: \
Proportion of the MAR predictor represented in the analysis model: pMAR = {1.0, 0.75, 0.5, 0.25, 0.0}\
Strength of correlations among the predictors: rXZ = {0.0, 0.1, 0.3, 0.5}\
Sample size: N = {100, 250, 500}\
Proportion of missing data: PM = {0.1, 0.2, 0.4}\
R^2^ for the data generating model: R^2 = {0.15, 0.3, 0.6}\
number of imputations:\ 
imputation type: MID, MI, CC 


## Importing data and libraries
```{r Imports}
#clear the working environment 
rm(list=ls())

#import libraries
library(ggplot2)
library(dplyr)

#import data
all_data <- readRDS("masked_outcome_measures.rds")
data_prb <- all_data$prb
data_mcsd <- all_data$mcsd
```

## 1. Understanding the structure of the data 
+ #### Data summaries\

```{r}
#general summary of the data
summary(data_prb)
summary(data_mcsd)
```
Columns **a** through **g** are the different conditions of the simulation. An interesting thing to note is that condition **1** of parameter **a** has only 540 occurrences and condition **8** of parameter **b** has 1620.\

+ #### Number of unique conditions for each parameter:\
```{r}
str(data_prb)
```
The analysis will begin with the PRB because it is necessary to understand which conditions are biased in order to make cross-references with the MCSD.

+ #### Boxplots with condition on the x-axis and PRB on y-axis for int, x, z1:\
```{r}
#boxplots for prb with the different conditions for x
for (i in 1:length(data_prb[1:7])){
  print(ggplot(data_prb, aes(x=data_prb[, i], y=x)) + geom_boxplot() + xlab(colnames(data_prb[i])))
}
```
```{r}
#boxplots for prb with the different conditions for int
for (i in 1:length(data_prb[1:7])){
  print(ggplot(data_prb, aes(x=data_prb[, i], y=int)) + geom_boxplot() + xlab(colnames(data_prb[i])))
}
```
```{r}
#boxplots for prb with the different conditions for z1
for (i in 1:length(data_prb[1:7])){
  print(ggplot(data_prb, aes(x=data_prb[, i], y=z1)) + geom_boxplot() + xlab(colnames(data_prb[i])))
}
```
Parameter **a**: The largest PRB for the slope and intercept is in condition **3** and in condition **1** for the auxiliary variable.\

Parameter **b**: The mean PRB for *x* in all conditions is almost identical and below zero. The situation is similar for *int*, except for condition **8** - The 75th percentile range is higher and there are more outliers. The mean and 75th percentile range for **z1** in condition **8** is higher and the mean is lower than the other conditions. 

Parameter **c**: The highest mean PRB for **x** is in condition **3**. For **int** the mean is the same across conditions, however the IQR increases. Same goes for **z1**, although the increase is not as drastic. 
Parameter **d**: The IQR decreases for **x** until condition **4**. For **int** the IQR decreases drastically. For **z1** the situation is more interesting - The IQR increases until condition **3** and then decreases again. 

Parameter **e**: The IQR decreases in each condition for **x**. For **int** and **z1** the PRB distribution looks identical across conditions, except for the many outliers in condition **1** for **z1**. 

Parameter **f**: There seems to be no visible difference across the conditions for all three parameters. 

Parameter **g**: The IQR becomes smaller for **int** and **z1**.  Almost no difference in conditions for **x**. 

```{r min and max values}
# min and max PRB for x
data_prb[which.min(abs(data_prb$x)),]
data_prb[which.max(abs(data_prb$x)),]

# min and max PRB for int
data_prb[which.min(abs(data_prb$int)),]
data_prb[which.max(abs(data_prb$int)),]

# min and max PRB for z1
data_prb[which.min(abs(data_prb$z1)),]
data_prb[which.max(abs(data_prb$z1)),]
```

```{r}
xtabs(~ a+b, data=data_prb)
```
Condition 1 for the a parameter is only paired with condition 8 of the b parameter.
```{r}
data_prb %>% filter(a == 2 & b==2 & c==1 & d==1 & e==1) %>% ggplot(aes(x=g, y=x)) + geom_boxplot()
```

For-loop comparing conditions of col f and col g

```{r}
#euclidean distance formula 
euclideanDistance <- function(x) sqrt(sum((x - mean(x))^2))
```

```{r Cond g}
#Loop comparing all possible conditions of col g 

#create a grid with all possible combinations from a-f
exp_data <- expand.grid(sapply(data_prb[1:6], levels))

#remove conditions where "a" is 1 and "b" is not 8
exp_data <- exp_data[!(exp_data$a == 1 & exp_data$b != 8), ]

#empty vector for saving Euc. distances
euc_dist_g <- rep(0, nrow(exp_data))

#looping through all possible conditions
for (n in 1:nrow(exp_data)){
  
  #filtering the data based on current set of conditions
  cols_exp <- colnames(exp_data)
  
  filt_data <- data_prb %>% filter(data_prb[, cols_exp[1]] == exp_data[n, 1], 
                                   b == exp_data$b[n], 
                                   c == exp_data$c[n], 
                                   d == exp_data$d[n], 
                                   e == exp_data$e[n], 
                                   f == exp_data$f[n])
  
  #calculating Euclidean distance
  euc_dist_g[n] <- euclideanDistance(filt_data$x)
  
  #saving the data
  data_euc_g <- cbind(exp_data, euc_dist_g)
}

```

```{r}
#Loop comparing all possible conditions of col g 

#create a grid with all possible combinations from a-f
exp_data <- expand.grid(sapply(data_prb[1:6], levels))

#remove conditions where "a" is 1 and "b" is not 8
exp_data <- exp_data[!(exp_data$a == 1 & exp_data$b != 8), ]

#empty vector for saving Euc. distances
euc_dist_g <- rep(0, nrow(exp_data))

#looping through all possible conditions
for (n in 1:nrow(exp_data)){
  
  #filtering the data based on current set of conditions
  cols_exp <- colnames(exp_data)
  
  
  
  filt_data <- data_prb %>% filter(data_prb[, cols_exp[1]] == exp_data[n, 1], 
                                   data_prb[, cols_exp[2]] == exp_data[n, 2], 
                                   data_prb[, cols_exp[3]] == exp_data[n, 3], 
                                   data_prb[, cols_exp[4]] == exp_data[n, 4], 
                                   data_prb[, cols_exp[5]] == exp_data[n, 5], 
                                   data_prb[, cols_exp[6]] == exp_data[n, 6])
  
  
  #calculating Euclidean distance
  euc_dist_g[n] <- euclideanDistance(filt_data$x)
  
  #saving the data
  data_euc_g <- cbind(exp_data, euc_dist_g)
  
}

```

```{r}
CalcEucDist <- function(data, col){
  
  #create a grid with all possible combinations 
  exp_data <- expand.grid(sapply(data[, -which(names(data) %in% c(col, "int", "x", "z1"))], levels))

  #remove conditions where "a" is 1 and "b" is not 8
  #exp_data <- exp_data[!(exp_data$a == 1 & exp_data$b != 8), ]

  #empty vector for saving Euc. distances
  euc_vec <- rep(0, nrow(exp_data))

  #looping through all possible conditions
  for (n in 1:nrow(exp_data)){
  
    #filtering the data based on current set of conditions
    cols_exp <- colnames(exp_data)
  
    filt_data <- data %>% filter(data[, cols_exp[1]] == exp_data[n, 1], 
                                 data[, cols_exp[2]] == exp_data[n, 2], 
                                 data[, cols_exp[3]] == exp_data[n, 3], 
                                 data[, cols_exp[4]] == exp_data[n, 4], 
                                 data[, cols_exp[5]] == exp_data[n, 5], 
                                 data[, cols_exp[6]] == exp_data[n, 6])
  
  
    #calculating Euclidean distance
    euc_vec[n] <- euclideanDistance(filt_data$x)
    
    #saving the data
    comb_data <- cbind(exp_data, euc_vec)
    out_data <- comb_data[comb_data$euc_vec != 0, ]
    out_data <- out_data[order(-out_data$euc_vec), ]
  }
  
  out_data
  
}

```

```{r}

start.time <- Sys.time()

params <- colnames(data_prb[1:7])

for(param in params){
  assign(paste0("data_", param), CalcEucDist(data_prb, param))
}

end.time <- Sys.time()
end.time - start.time

```

```{r}

data_a %>% ggplot(aes(x=euc_vec, col=c)) + geom_density()

```


